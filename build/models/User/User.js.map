{"version":3,"sources":["../../../server/models/User/User.js"],"names":["passwordValidator","is","min","has","uppercase","symbols","newUser","name","email","password","done","validate","hash","err","get","query","result","validateUser","rows","length","compare","res","token","sign","process","env","JWT_SECRET","user","valid"],"mappings":";;;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;AAEA;;;;AACA;;;;AAQA,IAAMA,oBAAoB,kCACvBC,EADuB,GAEvBC,GAFuB,CAEnB,EAFmB,EAGvBC,GAHuB,GAIvBC,SAJuB,GAKvBD,GALuB,GAMvBE,OANuB,EAA1B;;AAQO,IAAMC,4BAAU,SAAVA,OAAU,CAACC,IAAD,EAAOC,KAAP,EAAcC,QAAd,EAAwBC,IAAxB,EAAiC;AACtD,MAAI,CAACV,kBAAkBW,QAAlB,CAA2BF,QAA3B,CAAL,EAA2C;AACzCC,SAAK,EAAL;AACD,GAFD,MAEO,IAAI,CAAC,yBAAeC,QAAf,CAAwBH,KAAxB,CAAL,EAAqC;AAC1CE,SAAK,EAAL;AACD,GAFM,MAEA;AACL,qBAAOE,IAAP,CAAYH,QAAZ,EAAsB,EAAtB,EAA0B,UAACI,GAAD,EAAMD,IAAN,EAAe;AACvC,UAAIC,GAAJ,EAASH,KAAK,EAAL,wBAAT,KACK;AACH,qBACGI,GADH,GAEGC,KAFH,0DAII,CAACR,IAAD,EAAOC,KAAP,EAAcI,IAAd,CAJJ,EAKI,UAACC,GAAD,EAAMG,MAAN,EAAiB;AACfN,eAAK,EAAL,EAASG,GAAT;AACD,SAPL;AASD;AACF,KAbD;AAcD;AACF,CArBM;;AAuBA,IAAMI,sCAAe,SAAfA,YAAe,CAACT,KAAD,EAAQC,QAAR,EAAkBC,IAAlB,EAA2B;AACrD,eAAGI,GAAH,GAASC,KAAT,qCAAmD,CAACP,KAAD,CAAnD,EAA4D,UAACK,GAAD,EAAMK,IAAN,EAAe;AACzE,QAAIL,GAAJ,EAASH,KAAK,KAAL,EAAYG,GAAZ,EAAT,KACK,IAAIK,KAAKC,MAAL,KAAgB,CAApB,EAAuB;AAC1BT,WAAK,EAAL;AACD,KAFI,MAEE;AACL,uBAAOU,OAAP,CAAeX,QAAf,EAAyBS,KAAK,CAAL,EAAQN,IAAjC,EAAuC,UAACC,GAAD,EAAMQ,GAAN,EAAc;AACnD,YAAIA,GAAJ,EAAS;AACP;AACA,cAAMC,QAAQ,uBAAIC,IAAJ,CAASL,KAAK,CAAL,EAAQN,IAAjB,EAAuBY,QAAQC,GAAR,CAAYC,UAAnC,CAAd;AACAhB,eAAK;AACHiB,kBAAM;AACJnB,qBAAOU,KAAK,CAAL,EAAQV,KADX;AAEJD,oBAAMW,KAAK,CAAL,EAAQX;AAFV,aADH;AAKHe;AALG,WAAL;AAOD,SAVD,MAUO;AACLZ,eAAK,EAAEkB,OAAO,KAAT,EAAL;AACD;AACF,OAdD;AAeD;AACF,GArBD;AAsBD,CAvBM;;kBAyBQ;AACbtB,kBADa;AAEbW;AAFa,C","file":"User.js","sourcesContent":["import bcrypt from 'bcrypt';\nimport Validator from 'password-validator';\nimport jwt from 'jsonwebtoken';\nimport emailValidator from 'email-validator';\n\nimport db from '../../helpers/db';\nimport {\n  hashingError,\n  noUserError,\n  passwordValidationError,\n  emailValidationError,\n  invalidPasswordError,\n} from './errors';\n\nconst passwordValidator = new Validator()\n  .is()\n  .min(10)\n  .has()\n  .uppercase()\n  .has()\n  .symbols();\n\nexport const newUser = (name, email, password, done) => {\n  if (!passwordValidator.validate(password)) {\n    done({}, passwordValidationError);\n  } else if (!emailValidator.validate(email)) {\n    done({}, emailValidationError);\n  } else {\n    bcrypt.hash(password, 10, (err, hash) => {\n      if (err) done({}, hashingError);\n      else {\n        db\n          .get()\n          .query(\n            `INSERT INTO User (name, email, hash) values (?, ?, ?)`,\n            [name, email, hash],\n            (err, result) => {\n              done({}, err);\n            }\n          );\n      }\n    });\n  }\n};\n\nexport const validateUser = (email, password, done) => {\n  db.get().query(`SELECT * FROM User WHERE email=?`, [email], (err, rows) => {\n    if (err) done(false, err);\n    else if (rows.length === 0) {\n      done({}, noUserError);\n    } else {\n      bcrypt.compare(password, rows[0].hash, (err, res) => {\n        if (res) {\n          // We have a valid user...pass them a signed JWT token\n          const token = jwt.sign(rows[0].hash, process.env.JWT_SECRET);\n          done({\n            user: {\n              email: rows[0].email,\n              name: rows[0].name,\n            },\n            token,\n          });\n        } else {\n          done({ valid: false }, invalidPasswordError);\n        }\n      });\n    }\n  });\n};\n\nexport default {\n  newUser,\n  validateUser,\n};\n"]}